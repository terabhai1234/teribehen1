import heap
class Graph:
    def __init__(self, vertices):
        self.V = vertices
        self.graph = []
        self.adj_list = {i: [] for i in range(vertices)}

    def add_edge(self, u, v, w):
        self.graph.append((w, u, v))
        self.adj_list[u].append((v, w))
        self.adj_list[v].append((u, w))

    def kruskal_mst(self):
        def find(parent, i):
            if parent[i] == i:
                return i
            parent[i] = find(parent, parent[i])
            return parent[i]

        def union(parent, rank, x, y):
            xr, yr = find(parent, x), find(parent, y)
            if rank[xr] < rank[yr]:
                parent[xr] = yr
            elif rank[xr] > rank[yr]:
                parent[yr] = xr
            else:
                parent[yr] = xr
                rank[xr] += 1

        self.graph.sort()
        parent = list(range(self.V))
        rank = [0] * self.V
        mst = []

        for w, u, v in self.graph:
            if find(parent, u) != find(parent, v):
                mst.append((w, u, v))
                union(parent, rank, u, v)

        print("Kruskal's MST:")
        for w, u, v in mst:
            print(f"{u} -- {v} == {w}")

    def prim_mst(self):
        visited = [False] * self.V
        heap = [(0, 0, -1)]
        mst = []

        while heap:
            w, u, p = heapq.heappop(heap)
            if visited[u]:
                continue
            visited[u] = True
            if p != -1:
                mst.append((p, u, w))
            for v, wt in self.adj_list[u]:
                if not visited[v]:
                    heapq.heappush(heap, (wt, v, u))

        print("\nPrim's MST:")
        for u, v, w in mst:
            print(f"{u} -- {v} == {w}")

g = Graph(5)
g.add_edge(0, 1, 10)
g.add_edge(0, 2, 20)
g.add_edge(1, 2, 5)
g.add_edge(1, 3, 15)
g.add_edge(2, 3, 30)
g.add_edge(3, 4, 10)
g.add_edge(2, 4, 25)

g.kruskal_mst()
g.prim_mst()
